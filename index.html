<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üß© –ü–æ—Å—Ç–µ—Ä-–ú–æ–∑–∞–∏–∫–∞ ‚Äî –†–∞–∑–±–∏–≤–∫–∞ –∫–∞—Ä—Ç–∏–Ω–æ–∫ –Ω–∞ –ª–∏—Å—Ç—ã</title>
    
    <!-- –ë–∏–±–ª–∏–æ—Ç–µ–∫–∏ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.6.1/cropper.min.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.6.1/cropper.min.css" rel="stylesheet">
    <script src="https://unpkg.com/docx@8.5.0/build/index.umd.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf-lib/1.17.1/pdf-lib.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        :root {
            --primary: #4A90D9;
            --primary-hover: #357ABD;
            --success: #27AE60;
            --warning: #F39C12;
            --danger: #E74C3C;
            --bg: #F5F7FA;
            --card: #FFFFFF;
            --text: #2C3E50;
            --text-light: #7F8C8D;
            --border: #E1E8ED;
            --shadow: 0 4px 20px rgba(0,0,0,0.08);
            --radius: 16px;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
            font-size: 18px;
            line-height: 1.5;
        }
        
        .header {
            background: linear-gradient(135deg, var(--primary), #6C5CE7);
            color: white;
            padding: 24px;
            text-align: center;
            box-shadow: var(--shadow);
        }
        
        .header h1 { font-size: 2rem; font-weight: 700; margin-bottom: 8px; }
        .header p { opacity: 0.9; font-size: 1.1rem; }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 24px;
        }
        
        .steps {
            display: flex;
            justify-content: center;
            gap: 16px;
            margin-bottom: 32px;
            flex-wrap: wrap;
        }
        
        .step {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 24px;
            background: var(--card);
            border-radius: 50px;
            box-shadow: var(--shadow);
            opacity: 0.5;
            transition: all 0.3s;
        }
        
        .step.active { opacity: 1; background: var(--primary); color: white; }
        .step.completed { opacity: 1; background: var(--success); color: white; }
        
        .step-number {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: rgba(255,255,255,0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 1.1rem;
        }
        
        .card {
            background: var(--card);
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            padding: 32px;
            margin-bottom: 24px;
        }
        
        .card-title {
            font-size: 1.4rem;
            font-weight: 600;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .upload-zone {
            border: 3px dashed var(--border);
            border-radius: var(--radius);
            padding: 60px 40px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            background: linear-gradient(135deg, #f8f9fa, #fff);
        }
        
        .upload-zone:hover, .upload-zone.dragover {
            border-color: var(--primary);
            background: linear-gradient(135deg, #e8f4fd, #fff);
            transform: scale(1.01);
        }
        
        .upload-zone .icon { font-size: 4rem; margin-bottom: 20px; }
        .upload-zone h3 { font-size: 1.5rem; margin-bottom: 12px; }
        .upload-zone p { color: var(--text-light); font-size: 1.1rem; }
        .upload-zone input { display: none; }
        
        .two-columns {
            display: grid;
            grid-template-columns: 1fr 420px;
            gap: 24px;
            align-items: start;
        }
        
        @media (max-width: 1100px) {
            .two-columns { grid-template-columns: 1fr; }
        }
        
        /* ===== –ü–†–ï–í–¨–Æ ===== */
        .preview-section {
            background: #1a1a2e;
            border-radius: var(--radius);
            padding: 20px;
            position: relative;
        }
        
        .preview-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
            color: white;
        }
        
        .preview-header h3 {
            font-size: 1.1rem;
            font-weight: 500;
        }
        
        .preview-stats {
            display: flex;
            gap: 20px;
            font-size: 0.9rem;
        }
        
        .preview-stat {
            text-align: center;
        }
        
        .preview-stat-value {
            font-weight: 600;
            font-size: 1.1rem;
        }
        
        .preview-stat-label {
            opacity: 0.7;
            font-size: 0.8rem;
        }
        
        .quality-good { color: #27AE60; }
        .quality-medium { color: #F39C12; }
        .quality-bad { color: #E74C3C; }
        
        .preview-canvas-container {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 300px;
            background: #2d2d44;
            border-radius: 12px;
            overflow: hidden;
        }
        
        .preview-canvas-wrapper {
            position: relative;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
        }
        
        #previewCanvas {
            display: block;
            background: white;
        }
        
        .grid-lines {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
        }
        
        .preview-dimensions {
            position: absolute;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 0.8rem;
            font-weight: 500;
        }
        
        .dim-width {
            bottom: -30px;
            left: 50%;
            transform: translateX(-50%);
        }
        
        .dim-height {
            right: -70px;
            top: 50%;
            transform: translateY(-50%);
        }
        
        .sheet-label {
            position: absolute;
            background: rgba(255,255,255,0.95);
            color: #333;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.7rem;
            font-weight: 600;
            pointer-events: none;
        }
        
        .preview-legend {
            display: flex;
            gap: 20px;
            margin-top: 16px;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            color: rgba(255,255,255,0.8);
            font-size: 0.85rem;
        }
        
        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 4px;
        }
        
        .legend-full { background: rgba(74, 144, 217, 0.3); border: 2px solid rgba(74, 144, 217, 0.8); }
        .legend-partial { background: rgba(255, 193, 7, 0.3); border: 2px solid rgba(255, 193, 7, 0.8); }
        .legend-overlap { background: rgba(46, 204, 113, 0.4); border: 2px dashed rgba(46, 204, 113, 0.8); }
        
        .preview-actions {
            margin-top: 16px;
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
        }
        
        .preview-actions .btn { flex: 1; min-width: 140px; }
        
        /* ===== –ù–ê–°–¢–†–û–ô–ö–ò ===== */
        .settings-group {
            margin-bottom: 24px;
        }
        
        .settings-label {
            font-weight: 600;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 1.1rem;
        }
        
        .format-selector {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }
        
        .format-selector.three-cols { grid-template-columns: repeat(3, 1fr); }
        
        .format-btn {
            padding: 14px;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: white;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
            font-size: 1rem;
        }
        
        .format-btn:hover { border-color: var(--primary); background: #f0f7ff; }
        .format-btn.active { border-color: var(--primary); background: var(--primary); color: white; }
        
        .grid-selector {
            display: flex;
            align-items: center;
            gap: 12px;
            flex-wrap: wrap;
        }
        
        .grid-input {
            width: 70px;
            padding: 12px;
            border: 2px solid var(--border);
            border-radius: 10px;
            font-size: 1.2rem;
            text-align: center;
            font-weight: 600;
        }
        
        .grid-input:focus { outline: none; border-color: var(--primary); }
        .grid-x { font-size: 1.5rem; font-weight: 300; color: var(--text-light); }
        
        .auto-btn {
            padding: 12px 20px;
            background: var(--success);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 500;
            transition: all 0.2s;
        }
        
        .auto-btn:hover { background: #219a52; transform: translateY(-2px); }
        
        .toggle-group { display: flex; flex-direction: column; gap: 16px; }
        
        .toggle-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 16px;
            background: #f8f9fa;
            border-radius: 12px;
        }
        
        .toggle-label { font-size: 1rem; }
        
        .toggle-switch {
            position: relative;
            width: 60px;
            height: 32px;
            cursor: pointer;
            flex-shrink: 0;
        }
        
        .toggle-switch input { opacity: 0; width: 0; height: 0; }
        
        .toggle-slider {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: #ccc;
            border-radius: 32px;
            transition: 0.3s;
        }
        
        .toggle-slider:before {
            content: '';
            position: absolute;
            width: 26px;
            height: 26px;
            left: 3px;
            bottom: 3px;
            background: white;
            border-radius: 50%;
            transition: 0.3s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        .toggle-switch input:checked + .toggle-slider { background: var(--primary); }
        .toggle-switch input:checked + .toggle-slider:before { transform: translateX(28px); }
        
        .expandable-panel {
            margin-top: 12px;
            padding: 20px;
            background: #e8f4fd;
            border-radius: 12px;
            display: none;
        }
        
        .expandable-panel.visible { display: block; }
        
        .slider-group { margin-bottom: 16px; }
        .slider-group:last-child { margin-bottom: 0; }
        
        .slider-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 0.95rem;
        }
        
        .slider-value { font-weight: 600; color: var(--primary); }
        
        input[type="range"] {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: #ddd;
            outline: none;
            -webkit-appearance: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: var(--primary);
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
        }
        
        .preset-buttons {
            display: flex;
            gap: 8px;
            margin-bottom: 16px;
            flex-wrap: wrap;
        }
        
        .preset-btn {
            padding: 8px 16px;
            border: 2px solid var(--border);
            border-radius: 20px;
            background: white;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.2s;
        }
        
        .preset-btn:hover { border-color: var(--primary); }
        .preset-btn.active { background: var(--primary); border-color: var(--primary); color: white; }
        
        .dpi-selector {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-bottom: 12px;
        }
        
        .dpi-btn {
            padding: 8px 16px;
            border: 2px solid var(--border);
            border-radius: 8px;
            background: white;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.2s;
        }
        
        .dpi-btn:hover { border-color: var(--primary); }
        .dpi-btn.active { background: var(--primary); border-color: var(--primary); color: white; }
        
        .resolution-info {
            background: #fff;
            padding: 12px;
            border-radius: 8px;
            margin-top: 12px;
            font-size: 0.9rem;
        }
        
        .resolution-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
        }
        
        .resolution-row:last-child { margin-bottom: 0; }
        .resolution-label { color: var(--text-light); }
        .resolution-value { font-weight: 600; }
        
        .actions { display: flex; gap: 12px; margin-top: 24px; }
        
        .btn {
            flex: 1;
            padding: 18px 24px;
            border: none;
            border-radius: 12px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, var(--primary), #6C5CE7);
            color: white;
        }
        
        .btn-primary:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(74, 144, 217, 0.4);
        }
        
        .btn-secondary { background: #f0f0f0; color: var(--text); }
        .btn-secondary:hover { background: #e0e0e0; }
        
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }
        
        /* ===== –ú–û–î–ê–õ–ö–ò ===== */
        .modal {
            display: none;
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0,0,0,0.9);
            z-index: 1000;
            padding: 20px;
        }
        
        .modal.active { display: flex; flex-direction: column; }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px 24px;
            background: white;
            border-radius: 16px 16px 0 0;
        }
        
        .modal-title { font-size: 1.3rem; font-weight: 600; }
        
        .modal-close {
            width: 40px;
            height: 40px;
            border: none;
            background: #f0f0f0;
            border-radius: 50%;
            font-size: 1.5rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .modal-body {
            flex: 1;
            background: #1a1a2e;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }
        
        .modal-body img { max-width: 100%; max-height: 100%; }
        
        .modal-footer {
            display: flex;
            gap: 12px;
            padding: 16px 24px;
            background: white;
            border-radius: 0 0 16px 16px;
        }
        
        /* ===== –ü–†–û–ì–†–ï–°–° ===== */
        .progress-overlay {
            display: none;
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 2000;
            align-items: center;
            justify-content: center;
        }
        
        .progress-overlay.active { display: flex; }
        
        .progress-card {
            background: white;
            padding: 48px;
            border-radius: 20px;
            text-align: center;
            max-width: 400px;
            min-width: 300px;
        }
        
        .progress-spinner {
            width: 60px;
            height: 60px;
            border: 5px solid #f0f0f0;
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }
        
        @keyframes spin { to { transform: rotate(360deg); } }
        
        .progress-text { font-size: 1.1rem; color: var(--text); margin-bottom: 16px; }
        
        .progress-bar-container {
            background: #eee;
            border-radius: 10px;
            height: 12px;
            overflow: hidden;
        }
        
        .progress-bar {
            height: 100%;
            background: linear-gradient(135deg, var(--primary), #6C5CE7);
            width: 0%;
            transition: width 0.2s;
        }
        
        .progress-details {
            margin-top: 12px;
            font-size: 0.9rem;
            color: var(--text-light);
        }
        
        .hidden { display: none !important; }
        
        .badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 500;
        }
        
        .badge-info { background: #e8f4fd; color: var(--primary); }
        
        .hint {
            background: #fffbea;
            border-left: 4px solid var(--warning);
            padding: 16px;
            border-radius: 0 12px 12px 0;
            margin-top: 16px;
            font-size: 0.95rem;
        }
        
        .hint-title { font-weight: 600; margin-bottom: 4px; }
        
        .settings-scroll {
            max-height: calc(100vh - 200px);
            overflow-y: auto;
            padding-right: 8px;
        }
        
        .settings-scroll::-webkit-scrollbar { width: 6px; }
        .settings-scroll::-webkit-scrollbar-track { background: #f1f1f1; border-radius: 3px; }
        .settings-scroll::-webkit-scrollbar-thumb { background: #ccc; border-radius: 3px; }
        
        .error-message {
            background: #ffe0e0;
            border: 1px solid var(--danger);
            color: var(--danger);
            padding: 12px 16px;
            border-radius: 8px;
            margin-top: 12px;
            font-size: 0.95rem;
        }
        
        @media (max-width: 768px) {
            .header h1 { font-size: 1.5rem; }
            .steps { flex-direction: column; align-items: center; }
            .card { padding: 20px; }
            .upload-zone { padding: 40px 20px; }
            .format-selector, .format-selector.three-cols { grid-template-columns: 1fr; }
            .actions { flex-direction: column; }
            .preview-stats { flex-direction: column; gap: 8px; }
        }
    </style>
</head>
<body>
    <header class="header">
        <h1>üß© –ü–æ—Å—Ç–µ—Ä-–ú–æ–∑–∞–∏–∫–∞</h1>
        <p>–†–∞–∑–±–µ–π—Ç–µ –ª—é–±—É—é –∫–∞—Ä—Ç–∏–Ω–∫—É –Ω–∞ –ª–∏—Å—Ç—ã A4 –∏ –Ω–∞–ø–µ—á–∞—Ç–∞–π—Ç–µ –æ–≥—Ä–æ–º–Ω—ã–π –ø–æ—Å—Ç–µ—Ä!</p>
    </header>
    
    <main class="container">
        <div class="steps">
            <div class="step active" id="step1">
                <div class="step-number">1</div>
                <span>–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∫–∞—Ä—Ç–∏–Ω–∫—É</span>
            </div>
            <div class="step" id="step2">
                <div class="step-number">2</div>
                <span>–ù–∞—Å—Ç—Ä–æ–π—Ç–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã</span>
            </div>
            <div class="step" id="step3">
                <div class="step-number">3</div>
                <span>–°–∫–∞—á–∞–π—Ç–µ</span>
            </div>
        </div>
        
        <!-- –ó–∞–≥—Ä—É–∑–∫–∞ -->
        <div class="card" id="uploadCard">
            <div class="upload-zone" id="uploadZone">
                <div class="icon">üìÅ</div>
                <h3>–ü–µ—Ä–µ—Ç–∞—â–∏—Ç–µ –∫–∞—Ä—Ç–∏–Ω–∫—É —Å—é–¥–∞</h3>
                <p>–∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ, —á—Ç–æ–±—ã –≤—ã–±—Ä–∞—Ç—å —Ñ–∞–π–ª</p>
                <p style="margin-top: 12px;"><span class="badge badge-info">JPG, PNG, WebP –¥–æ 50 –ú–ë</span></p>
                <input type="file" id="fileInput" accept="image/*">
            </div>
            <div class="error-message hidden" id="uploadError"></div>
        </div>
        
        <!-- –†–µ–¥–∞–∫—Ç–æ—Ä -->
        <div class="hidden" id="editorSection">
            <div class="two-columns">
                <!-- –ü—Ä–µ–≤—å—é -->
                <div class="card">
                    <div class="preview-section">
                        <div class="preview-header">
                            <h3>üìê –°—Ö–µ–º–∞ —Ä–∞–∑–±–∏–≤–∫–∏</h3>
                            <div class="preview-stats">
                                <div class="preview-stat">
                                    <div class="preview-stat-value" id="statPosterSize">‚Äî</div>
                                    <div class="preview-stat-label">–†–∞–∑–º–µ—Ä –ø–æ—Å—Ç–µ—Ä–∞</div>
                                </div>
                                <div class="preview-stat">
                                    <div class="preview-stat-value" id="statSheets">‚Äî</div>
                                    <div class="preview-stat-label">–õ–∏—Å—Ç–æ–≤</div>
                                </div>
                                <div class="preview-stat">
                                    <div class="preview-stat-value" id="statQuality">‚Äî</div>
                                    <div class="preview-stat-label">–ö–∞—á–µ—Å—Ç–≤–æ</div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="preview-canvas-container">
                            <div class="preview-canvas-wrapper" id="previewWrapper">
                                <canvas id="previewCanvas"></canvas>
                                <svg class="grid-lines" id="gridLines"></svg>
                                <div class="preview-dimensions dim-width" id="dimWidth">‚Äî</div>
                                <div class="preview-dimensions dim-height" id="dimHeight">‚Äî</div>
                            </div>
                        </div>
                        
                        <div class="preview-legend" id="previewLegend">
                            <div class="legend-item">
                                <div class="legend-color legend-full"></div>
                                <span>–ü–æ–ª–Ω—ã–π –ª–∏—Å—Ç</span>
                            </div>
                            <div class="legend-item hidden" id="legendPartial">
                                <div class="legend-color legend-partial"></div>
                                <span>–ß–∞—Å—Ç–∏—á–Ω—ã–π</span>
                            </div>
                            <div class="legend-item hidden" id="legendOverlap">
                                <div class="legend-color legend-overlap"></div>
                                <span>–ù–∞—Ö–ª—ë—Å—Ç</span>
                            </div>
                        </div>
                    </div>
                    
                    <div class="preview-actions">
                        <button class="btn btn-secondary" onclick="openCropper()">‚úÇÔ∏è –û–±—Ä–µ–∑–∞—Ç—å</button>
                        <button class="btn btn-secondary" onclick="resetImage()">üîÑ –î—Ä—É–≥–∞—è –∫–∞—Ä—Ç–∏–Ω–∫–∞</button>
                    </div>
                </div>
                
                <!-- –ù–∞—Å—Ç—Ä–æ–π–∫–∏ -->
                <div class="card">
                    <div class="card-title">
                        <span class="icon">‚öôÔ∏è</span>
                        –ù–∞—Å—Ç—Ä–æ–π–∫–∏
                    </div>
                    
                    <div class="settings-scroll">
                        <!-- –†–µ–∂–∏–º -->
                        <div class="settings-group">
                            <div class="settings-label">üñºÔ∏è –†–∞–∑–º–µ—â–µ–Ω–∏–µ</div>
                            <div class="format-selector" id="fitModeSelector">
                                <button class="format-btn active" data-fitmode="fit">üìê –í–ø–∏—Å–∞—Ç—å —Ü–µ–ª–∏–∫–æ–º</button>
                                <button class="format-btn" data-fitmode="fill">üî≤ –ó–∞–ø–æ–ª–Ω–∏—Ç—å —Å–µ—Ç–∫—É</button>
                            </div>
                        </div>
                        
                        <!-- –§–æ—Ä–º–∞—Ç -->
                        <div class="settings-group">
                            <div class="settings-label">üìÑ –§–æ—Ä–º–∞—Ç –±—É–º–∞–≥–∏</div>
                            <div class="format-selector" id="paperFormatSelector">
                                <button class="format-btn active" data-format="A4">A4</button>
                                <button class="format-btn" data-format="A3">A3</button>
                                <button class="format-btn" data-format="A5">A5</button>
                                <button class="format-btn" data-format="Letter">Letter</button>
                            </div>
                        </div>
                        
                        <!-- –û—Ä–∏–µ–Ω—Ç–∞—Ü–∏—è -->
                        <div class="settings-group">
                            <div class="settings-label">üìê –û—Ä–∏–µ–Ω—Ç–∞—Ü–∏—è</div>
                            <div class="format-selector" id="orientationSelector">
                                <button class="format-btn active" data-orientation="portrait">üìÉ –ü–æ—Ä—Ç—Ä–µ—Ç</button>
                                <button class="format-btn" data-orientation="landscape">üìÉ –ê–ª—å–±–æ–º</button>
                            </div>
                        </div>
                        
                        <!-- –°–µ—Ç–∫–∞ -->
                        <div class="settings-group">
                            <div class="settings-label">üî¢ –õ–∏—Å—Ç–æ–≤</div>
                            <div class="grid-selector">
                                <input type="number" class="grid-input" id="gridCols" value="2" min="1" max="20">
                                <span class="grid-x">√ó</span>
                                <input type="number" class="grid-input" id="gridRows" value="2" min="1" max="20">
                                <button class="auto-btn" onclick="autoGrid()">‚ú® –ê–≤—Ç–æ</button>
                            </div>
                        </div>
                        
                        <!-- –ê–ø—Å–∫–µ–π–ª -->
                        <div class="settings-group">
                            <div class="settings-label">üîç –£–ª—É—á—à–µ–Ω–∏–µ –∫–∞—á–µ—Å—Ç–≤–∞</div>
                            <div class="toggle-group">
                                <div class="toggle-item">
                                    <span class="toggle-label">–ê–ø—Å–∫–µ–π–ª –∏ –æ–±—Ä–∞–±–æ—Ç–∫–∞</span>
                                    <label class="toggle-switch">
                                        <input type="checkbox" id="enableUpscale">
                                        <span class="toggle-slider"></span>
                                    </label>
                                </div>
                            </div>
                            
                            <div class="expandable-panel" id="upscalePanel">
                                <div class="settings-label" style="font-size: 1rem;">–¶–µ–ª–µ–≤–æ–µ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–µ (DPI)</div>
                                <div class="dpi-selector">
                                    <button class="dpi-btn" data-dpi="72">72</button>
                                    <button class="dpi-btn active" data-dpi="150">150</button>
                                    <button class="dpi-btn" data-dpi="300">300</button>
                                    <button class="dpi-btn" data-dpi="custom">–°–≤–æ—ë</button>
                                </div>
                                <div class="hidden" id="customDpiWrapper">
                                    <input type="number" class="grid-input" id="customDpi" value="200" min="72" max="600" style="width: 100px;">
                                    <span style="margin-left: 8px;">DPI</span>
                                </div>
                                
                                <div class="resolution-info" id="resolutionInfo">
                                    <div class="resolution-row">
                                        <span class="resolution-label">–ò—Å—Ö–æ–¥–Ω–æ–µ:</span>
                                        <span class="resolution-value" id="resOriginal">‚Äî</span>
                                    </div>
                                    <div class="resolution-row">
                                        <span class="resolution-label">–ò—Ç–æ–≥–æ–≤–æ–µ:</span>
                                        <span class="resolution-value" id="resTarget">‚Äî</span>
                                    </div>
                                    <div class="resolution-row">
                                        <span class="resolution-label">–ú–∞—Å—à—Ç–∞–±:</span>
                                        <span class="resolution-value" id="resScale">‚Äî</span>
                                    </div>
                                </div>
                                
                                <div style="margin-top: 16px;">
                                    <div class="settings-label" style="font-size: 1rem;">–ü—Ä–µ—Å–µ—Ç</div>
                                    <div class="preset-buttons">
                                        <button class="preset-btn active" data-preset="photo">üì∑ –§–æ—Ç–æ</button>
                                        <button class="preset-btn" data-preset="art">üé® –†–∏—Å—É–Ω–æ–∫</button>
                                        <button class="preset-btn" data-preset="pixel">üëæ –ü–∏–∫—Å–µ–ª—å–∞—Ä—Ç</button>
                                        <button class="preset-btn" data-preset="custom">‚öôÔ∏è –°–≤–æ—ë</button>
                                    </div>
                                </div>
                                
                                <div class="slider-group">
                                    <div class="slider-header">
                                        <span>–†–µ–∑–∫–æ—Å—Ç—å</span>
                                        <span class="slider-value" id="sharpenValue">30%</span>
                                    </div>
                                    <input type="range" id="sharpenSlider" min="0" max="100" value="30">
                                </div>
                                
                                <div class="slider-group">
                                    <div class="slider-header">
                                        <span>–ö–æ–Ω—Ç—Ä–∞—Å—Ç</span>
                                        <span class="slider-value" id="contrastValue">10%</span>
                                    </div>
                                    <input type="range" id="contrastSlider" min="-50" max="50" value="10">
                                </div>
                                
                                <div class="slider-group">
                                    <div class="slider-header">
                                        <span>–Ø—Ä–∫–æ—Å—Ç—å</span>
                                        <span class="slider-value" id="brightnessValue">0%</span>
                                    </div>
                                    <input type="range" id="brightnessSlider" min="-50" max="50" value="0">
                                </div>
                                
                                <div class="slider-group">
                                    <div class="slider-header">
                                        <span>–ù–∞—Å—ã—â–µ–Ω–Ω–æ—Å—Ç—å</span>
                                        <span class="slider-value" id="saturationValue">5%</span>
                                    </div>
                                    <input type="range" id="saturationSlider" min="-50" max="50" value="5">
                                </div>
                            </div>
                        </div>
                        
                        <!-- –ù–∞—Ö–ª—ë—Å—Ç -->
                        <div class="settings-group">
                            <div class="settings-label">üìé –ù–∞—Ö–ª—ë—Å—Ç</div>
                            <div class="toggle-group">
                                <div class="toggle-item">
                                    <span class="toggle-label">–î–ª—è —Å–∫–ª–µ–π–∫–∏ –≤–Ω–∞—Ö–ª—ë—Å—Ç</span>
                                    <label class="toggle-switch">
                                        <input type="checkbox" id="enableOverlap">
                                        <span class="toggle-slider"></span>
                                    </label>
                                </div>
                            </div>
                            
                            <div class="expandable-panel" id="overlapPanel">
                                <div class="slider-group">
                                    <div class="slider-header">
                                        <span>–†–∞–∑–º–µ—Ä –Ω–∞—Ö–ª—ë—Å—Ç–∞</span>
                                        <span class="slider-value" id="overlapValue">15 –º–º</span>
                                    </div>
                                    <input type="range" id="overlapSlider" min="5" max="30" value="15">
                                </div>
                            </div>
                        </div>
                        
                        <!-- –≠–∫—Å–ø–æ—Ä—Ç -->
                        <div class="settings-group">
                            <div class="settings-label">üíæ –§–æ—Ä–º–∞—Ç</div>
                            <div class="format-selector three-cols" id="exportFormatSelector">
                                <button class="format-btn active" data-export="docx">üìÑ DOCX</button>
                                <button class="format-btn" data-export="pdf">üìï PDF</button>
                                <button class="format-btn" data-export="zip">üì¶ ZIP</button>
                            </div>
                        </div>
                        
                        <div class="actions">
                            <button class="btn btn-primary" id="generateBtn" onclick="generateOutput()">
                                üöÄ –°–æ–∑–¥–∞—Ç—å –ø–æ—Å—Ç–µ—Ä
                            </button>
                        </div>
                        
                        <div class="hint">
                            <div class="hint-title">üí° –°–æ–≤–µ—Ç</div>
                            –í–∫–ª—é—á–∏—Ç–µ –∞–ø—Å–∫–µ–π–ª –¥–ª—è –ø–æ–≤—ã—à–µ–Ω–∏—è –∫–∞—á–µ—Å—Ç–≤–∞. –ß–µ–º –≤—ã—à–µ DPI, —Ç–µ–º —á—ë—Ç—á–µ –ø–µ—á–∞—Ç—å, –Ω–æ –¥–æ–ª—å—à–µ –æ–±—Ä–∞–±–æ—Ç–∫–∞.
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </main>
    
    <!-- –ö—Ä–æ–ø–ø–µ—Ä -->
    <div class="modal" id="cropperModal">
        <div class="modal-header">
            <div class="modal-title">‚úÇÔ∏è –û–±—Ä–µ–∑–∫–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è</div>
            <button class="modal-close" onclick="closeCropper()">√ó</button>
        </div>
        <div class="modal-body">
            <img id="cropperImage" src="">
        </div>
        <div class="modal-footer">
            <button class="btn btn-secondary" style="flex:1" onclick="closeCropper()">–û—Ç–º–µ–Ω–∞</button>
            <button class="btn btn-primary" style="flex:1" onclick="applyCrop()">‚úì –ü—Ä–∏–º–µ–Ω–∏—Ç—å</button>
        </div>
    </div>
    
    <!-- –ü—Ä–æ–≥—Ä–µ—Å—Å -->
    <div class="progress-overlay" id="progressOverlay">
        <div class="progress-card">
            <div class="progress-spinner"></div>
            <div class="progress-text" id="progressText">–ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞...</div>
            <div class="progress-bar-container">
                <div class="progress-bar" id="progressBar"></div>
            </div>
            <div class="progress-details" id="progressDetails"></div>
        </div>
    </div>

    <script>
    // ============================================
    // –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø
    // ============================================
    const CONFIG = {
        paperSizes: {
            'A4': { width: 210, height: 297 },
            'A3': { width: 297, height: 420 },
            'A5': { width: 148, height: 210 },
            'Letter': { width: 215.9, height: 279.4 }
        },
        previewMaxSize: 500,
        mmToInch: 25.4,
        mmToPoint: 2.83465,
        chunkSize: 50000, // –ø–∏–∫—Å–µ–ª–µ–π –∑–∞ –∏—Ç–µ—Ä–∞—Ü–∏—é –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏
        presets: {
            photo: { sharpen: 30, contrast: 10, brightness: 0, saturation: 5 },
            art: { sharpen: 50, contrast: 15, brightness: 0, saturation: 10 },
            pixel: { sharpen: 0, contrast: 0, brightness: 0, saturation: 0 },
            custom: { sharpen: 30, contrast: 10, brightness: 0, saturation: 5 }
        }
    };

    // ============================================
    // –°–û–°–¢–û–Ø–ù–ò–ï
    // ============================================
    const state = {
        // –ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ
        originalImage: null,
        originalDataUrl: null,
        imageWidth: 0,
        imageHeight: 0,
        
        // –ù–∞—Å—Ç—Ä–æ–π–∫–∏
        fitMode: 'fit',
        paperFormat: 'A4',
        orientation: 'portrait',
        gridCols: 2,
        gridRows: 2,
        
        // –ê–ø—Å–∫–µ–π–ª
        enableUpscale: false,
        targetDPI: 150,
        customDPI: 200,
        upscalePreset: 'photo',
        sharpen: 30,
        contrast: 10,
        brightness: 0,
        saturation: 5,
        
        // –ù–∞—Ö–ª—ë—Å—Ç
        enableOverlap: false,
        overlapAmount: 15,
        
        // –≠–∫—Å–ø–æ—Ä—Ç
        exportFormat: 'docx',
        
        // –í–Ω—É—Ç—Ä–µ–Ω–Ω–µ–µ
        cropper: null,
        isProcessing: false,
        abortController: null
    };

    // ============================================
    // –£–¢–ò–õ–ò–¢–´
    // ============================================
    
    // –ë–µ–∑–æ–ø–∞—Å–Ω–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ –¥–ª—è —Ä–∞–∑–≥—Ä—É–∑–∫–∏ main thread
    const delay = (ms = 0) => new Promise(r => setTimeout(r, ms));
    
    // –†–∞–∑–±–∏–µ–Ω–∏–µ —Ç—è–∂—ë–ª–æ–π —Ä–∞–±–æ—Ç—ã –Ω–∞ —á–∞–Ω–∫–∏
    async function processInChunks(totalItems, chunkSize, callback, onProgress) {
        let processed = 0;
        while (processed < totalItems) {
            const end = Math.min(processed + chunkSize, totalItems);
            await callback(processed, end);
            processed = end;
            if (onProgress) onProgress(processed / totalItems);
            await delay(0); // –û—Ç–¥–∞—ë–º –∫–æ–Ω—Ç—Ä–æ–ª—å –±—Ä–∞—É–∑–µ—Ä—É
        }
    }
    
    // –û—á–∏—Å—Ç–∫–∞ —Ä–µ—Å—É—Ä—Å–æ–≤
    function cleanupBlob(blob) {
        if (blob && blob instanceof Blob) {
            // Blob –±—É–¥–µ—Ç –æ—á–∏—â–µ–Ω GC –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏
        }
    }
    
    function cleanupCanvas(canvas) {
        if (canvas) {
            const ctx = canvas.getContext('2d');
            if (ctx) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
            }
            canvas.width = 1;
            canvas.height = 1;
        }
    }

    // –ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ –ø–æ–ª—É—á–µ–Ω–∏–µ —Ä–∞–∑–º–µ—Ä–∞ –±—É–º–∞–≥–∏
    function getPaperSize() {
        const size = CONFIG.paperSizes[state.paperFormat] || CONFIG.paperSizes['A4'];
        if (state.orientation === 'landscape') {
            return { width: size.height, height: size.width };
        }
        return { width: size.width, height: size.height };
    }
    
    // –°–∫–ª–æ–Ω–µ–Ω–∏–µ —Å–ª–æ–≤
    function getSheetWord(n) {
        const abs = Math.abs(n) % 100;
        const lastDigit = abs % 10;
        if (abs >= 11 && abs <= 14) return '–ª–∏—Å—Ç–æ–≤';
        if (lastDigit === 1) return '–ª–∏—Å—Ç';
        if (lastDigit >= 2 && lastDigit <= 4) return '–ª–∏—Å—Ç–∞';
        return '–ª–∏—Å—Ç–æ–≤';
    }

    // ============================================
    // –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø
    // ============================================
    document.addEventListener('DOMContentLoaded', () => {
        try {
            initUpload();
            initSettings();
        } catch (e) {
            console.error('Init error:', e);
        }
    });

    function initUpload() {
        const uploadZone = document.getElementById('uploadZone');
        const fileInput = document.getElementById('fileInput');
        
        uploadZone.addEventListener('click', () => fileInput.click());
        
        fileInput.addEventListener('change', (e) => {
            const file = e.target.files?.[0];
            if (file) loadImage(file);
        });
        
        uploadZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.stopPropagation();
            uploadZone.classList.add('dragover');
        });
        
        uploadZone.addEventListener('dragleave', (e) => {
            e.preventDefault();
            e.stopPropagation();
            uploadZone.classList.remove('dragover');
        });
        
        uploadZone.addEventListener('drop', (e) => {
            e.preventDefault();
            e.stopPropagation();
            uploadZone.classList.remove('dragover');
            const file = e.dataTransfer?.files?.[0];
            if (file && file.type.startsWith('image/')) {
                loadImage(file);
            } else {
                showError('–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ (JPG, PNG, WebP)');
            }
        });
    }

    function initSettings() {
        // –†–µ–∂–∏–º —Ä–∞–∑–º–µ—â–µ–Ω–∏—è
        setupButtonGroup('#fitModeSelector [data-fitmode]', (btn) => {
            state.fitMode = btn.dataset.fitmode;
            schedulePreviewUpdate();
        });
        
        // –§–æ—Ä–º–∞—Ç –±—É–º–∞–≥–∏
        setupButtonGroup('#paperFormatSelector [data-format]', (btn) => {
            state.paperFormat = btn.dataset.format;
            schedulePreviewUpdate();
        });
        
        // –û—Ä–∏–µ–Ω—Ç–∞—Ü–∏—è
        setupButtonGroup('#orientationSelector [data-orientation]', (btn) => {
            state.orientation = btn.dataset.orientation;
            schedulePreviewUpdate();
        });
        
        // –°–µ—Ç–∫–∞
        document.getElementById('gridCols').addEventListener('input', (e) => {
            state.gridCols = Math.max(1, Math.min(20, parseInt(e.target.value) || 1));
            schedulePreviewUpdate();
        });
        
        document.getElementById('gridRows').addEventListener('input', (e) => {
            state.gridRows = Math.max(1, Math.min(20, parseInt(e.target.value) || 1));
            schedulePreviewUpdate();
        });
        
        // –ê–ø—Å–∫–µ–π–ª
        document.getElementById('enableUpscale').addEventListener('change', (e) => {
            state.enableUpscale = e.target.checked;
            document.getElementById('upscalePanel').classList.toggle('visible', e.target.checked);
            updateResolutionInfo();
        });
        
        // DPI
        setupButtonGroup('.dpi-btn[data-dpi]', (btn) => {
            const dpi = btn.dataset.dpi;
            const customWrapper = document.getElementById('customDpiWrapper');
            
            if (dpi === 'custom') {
                customWrapper.classList.remove('hidden');
                state.targetDPI = parseInt(document.getElementById('customDpi').value) || 200;
            } else {
                customWrapper.classList.add('hidden');
                state.targetDPI = parseInt(dpi);
            }
            updateResolutionInfo();
        });
        
        document.getElementById('customDpi').addEventListener('input', (e) => {
            state.targetDPI = Math.max(72, Math.min(600, parseInt(e.target.value) || 150));
            state.customDPI = state.targetDPI;
            updateResolutionInfo();
        });
        
        // –ü—Ä–µ—Å–µ—Ç—ã
        setupButtonGroup('.preset-btn[data-preset]', (btn) => {
            state.upscalePreset = btn.dataset.preset;
            if (btn.dataset.preset !== 'custom') {
                applyPreset(btn.dataset.preset);
            }
        });
        
        // –°–ª–∞–π–¥–µ—Ä—ã –æ–±—Ä–∞–±–æ—Ç–∫–∏
        ['sharpen', 'contrast', 'brightness', 'saturation'].forEach(param => {
            const slider = document.getElementById(param + 'Slider');
            const valueEl = document.getElementById(param + 'Value');
            
            slider?.addEventListener('input', (e) => {
                state[param] = parseInt(e.target.value);
                valueEl.textContent = e.target.value + '%';
                
                // –ü–µ—Ä–µ–∫–ª—é—á–∞–µ–º—Å—è –Ω–∞ "–°–≤–æ—ë"
                document.querySelectorAll('.preset-btn[data-preset]').forEach(b => b.classList.remove('active'));
                document.querySelector('.preset-btn[data-preset="custom"]')?.classList.add('active');
                state.upscalePreset = 'custom';
            });
        });
        
        // –ù–∞—Ö–ª—ë—Å—Ç
        document.getElementById('enableOverlap').addEventListener('change', (e) => {
            state.enableOverlap = e.target.checked;
            document.getElementById('overlapPanel').classList.toggle('visible', e.target.checked);
            document.getElementById('legendOverlap').classList.toggle('hidden', !e.target.checked);
            schedulePreviewUpdate();
        });
        
        document.getElementById('overlapSlider').addEventListener('input', (e) => {
            state.overlapAmount = parseInt(e.target.value);
            document.getElementById('overlapValue').textContent = e.target.value + ' –º–º';
            schedulePreviewUpdate();
        });
        
        // –§–æ—Ä–º–∞—Ç —ç–∫—Å–ø–æ—Ä—Ç–∞
        setupButtonGroup('#exportFormatSelector [data-export]', (btn) => {
            state.exportFormat = btn.dataset.export;
        });
    }
    
    function setupButtonGroup(selector, callback) {
        document.querySelectorAll(selector).forEach(btn => {
            btn.addEventListener('click', () => {
                btn.parentElement.querySelectorAll('.format-btn, .preset-btn, .dpi-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                callback(btn);
            });
        });
    }
    
    function applyPreset(presetName) {
        const preset = CONFIG.presets[presetName];
        if (!preset) return;
        
        Object.entries(preset).forEach(([key, value]) => {
            state[key] = value;
            const slider = document.getElementById(key + 'Slider');
            const valueEl = document.getElementById(key + 'Value');
            if (slider) slider.value = value;
            if (valueEl) valueEl.textContent = value + '%';
        });
    }

    // ============================================
    // –ó–ê–ì–†–£–ó–ö–ê –ò–ó–û–ë–†–ê–ñ–ï–ù–ò–Ø
    // ============================================
    function loadImage(file) {
        hideError();
        
        // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ä–∞–∑–º–µ—Ä–∞
        if (file.size > 50 * 1024 * 1024) {
            showError('–§–∞–π–ª —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–π. –ú–∞–∫—Å–∏–º—É–º 50 –ú–ë.');
            return;
        }
        
        // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ç–∏–ø–∞
        if (!file.type.startsWith('image/')) {
            showError('–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ.');
            return;
        }
        
        const reader = new FileReader();
        
        reader.onerror = () => {
            showError('–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ—á–∏—Ç–∞—Ç—å —Ñ–∞–π–ª.');
        };
        
        reader.onload = (e) => {
            const img = new Image();
            
            img.onerror = () => {
                showError('–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ. –í–æ–∑–º–æ–∂–Ω–æ, —Ñ–∞–π–ª –ø–æ–≤—Ä–µ–∂–¥—ë–Ω.');
            };
            
            img.onload = () => {
                try {
                    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ
                    if (img.naturalWidth * img.naturalHeight > 100000000) {
                        showError('–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–µ (–±–æ–ª–µ–µ 100 –º–µ–≥–∞–ø–∏–∫—Å–µ–ª–µ–π).');
                        return;
                    }
                    
                    state.originalImage = img;
                    state.originalDataUrl = e.target.result;
                    state.imageWidth = img.naturalWidth;
                    state.imageHeight = img.naturalHeight;
                    
                    document.getElementById('uploadCard').classList.add('hidden');
                    document.getElementById('editorSection').classList.remove('hidden');
                    
                    document.getElementById('step1').classList.remove('active');
                    document.getElementById('step1').classList.add('completed');
                    document.getElementById('step2').classList.add('active');
                    
                    autoGrid();
                    updateResolutionInfo();
                    
                } catch (err) {
                    console.error('Error loading image:', err);
                    showError('–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è.');
                }
            };
            
            img.src = e.target.result;
        };
        
        reader.readAsDataURL(file);
    }
    
    function resetImage() {
        // –û—á–∏—â–∞–µ–º —Ä–µ—Å—É—Ä—Å—ã
        if (state.cropper) {
            state.cropper.destroy();
            state.cropper = null;
        }
        
        state.originalImage = null;
        state.originalDataUrl = null;
        
        document.getElementById('uploadCard').classList.remove('hidden');
        document.getElementById('editorSection').classList.add('hidden');
        document.getElementById('fileInput').value = '';
        
        document.getElementById('step1').classList.add('active');
        document.getElementById('step1').classList.remove('completed');
        document.getElementById('step2').classList.remove('active');
        document.getElementById('step3').classList.remove('active', 'completed');
        
        hideError();
    }
    
    function showError(message) {
        const errorEl = document.getElementById('uploadError');
        errorEl.textContent = message;
        errorEl.classList.remove('hidden');
    }
    
    function hideError() {
        document.getElementById('uploadError').classList.add('hidden');
    }

    // ============================================
    // –ê–í–¢–û-–ü–û–î–ë–û–† –°–ï–¢–ö–ò
    // ============================================
    function autoGrid() {
        if (!state.originalImage) return;
        
        const paper = getPaperSize();
        const imgRatio = state.imageWidth / state.imageHeight;
        const paperRatio = paper.width / paper.height;
        
        let bestCols = 2, bestRows = 2;
        let bestDiff = Infinity;
        
        // –ò—â–µ–º –æ–ø—Ç–∏–º–∞–ª—å–Ω—É—é —Å–µ—Ç–∫—É
        for (let cols = 1; cols <= 6; cols++) {
            for (let rows = 1; rows <= 6; rows++) {
                const gridRatio = (cols * paper.width) / (rows * paper.height);
                const diff = Math.abs(gridRatio - imgRatio);
                
                if (diff < bestDiff) {
                    bestDiff = diff;
                    bestCols = cols;
                    bestRows = rows;
                }
            }
        }
        
        state.gridCols = bestCols;
        state.gridRows = bestRows;
        document.getElementById('gridCols').value = bestCols;
        document.getElementById('gridRows').value = bestRows;
        
        updatePreview();
    }

    // ============================================
    // –ò–ù–§–û–†–ú–ê–¶–ò–Ø –û –†–ê–ó–†–ï–®–ï–ù–ò–ò
    // ============================================
    function updateResolutionInfo() {
        if (!state.originalImage) return;
        
        const paper = getPaperSize();
        const gridWidthMM = paper.width * state.gridCols;
        const gridHeightMM = paper.height * state.gridRows;
        
        // –ò—Å—Ö–æ–¥–Ω–æ–µ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–µ
        document.getElementById('resOriginal').textContent = 
            `${state.imageWidth} √ó ${state.imageHeight} px`;
        
        // –¶–µ–ª–µ–≤–æ–µ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–µ –ø—Ä–∏ –≤—ã–±—Ä–∞–Ω–Ω–æ–º DPI
        const targetWidth = Math.round((gridWidthMM / CONFIG.mmToInch) * state.targetDPI);
        const targetHeight = Math.round((gridHeightMM / CONFIG.mmToInch) * state.targetDPI);
        
        document.getElementById('resTarget').textContent = 
            `${targetWidth} √ó ${targetHeight} px`;
        
        // –ú–∞—Å—à—Ç–∞–±
        const scaleX = targetWidth / state.imageWidth;
        const scaleY = targetHeight / state.imageHeight;
        const scale = Math.max(scaleX, scaleY);
        
        const scaleEl = document.getElementById('resScale');
        if (scale > 1) {
            scaleEl.textContent = `√ó${scale.toFixed(1)} (—É–≤–µ–ª–∏—á–µ–Ω–∏–µ)`;
            scaleEl.style.color = scale > 3 ? 'var(--danger)' : scale > 2 ? 'var(--warning)' : 'var(--success)';
        } else {
            scaleEl.textContent = `√ó${scale.toFixed(2)} (—É–º–µ–Ω—å—à–µ–Ω–∏–µ)`;
            scaleEl.style.color = 'var(--success)';
        }
    }

    // ============================================
    // –ü–†–ï–í–¨–Æ
    // ============================================
    let previewTimeout = null;
    
    function schedulePreviewUpdate() {
        if (previewTimeout) clearTimeout(previewTimeout);
        previewTimeout = setTimeout(() => {
            updatePreview();
            updateResolutionInfo();
        }, 50);
    }
    
    function updatePreview() {
        if (!state.originalImage) return;
        
        try {
            const canvas = document.getElementById('previewCanvas');
            const ctx = canvas.getContext('2d');
            const paper = getPaperSize();
            
            // –†–∞–∑–º–µ—Ä—ã —Å–µ—Ç–∫–∏ –≤ –º–º
            const gridWidthMM = paper.width * state.gridCols;
            const gridHeightMM = paper.height * state.gridRows;
            const gridRatio = gridWidthMM / gridHeightMM;
            
            // –†–∞–∑–º–µ—Ä—ã –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
            const imgRatio = state.imageWidth / state.imageHeight;
            
            // –†–∞–∑–º–µ—Ä—ã –ø—Ä–µ–≤—å—é (canvas)
            let canvasWidth, canvasHeight;
            if (gridRatio > 1) {
                canvasWidth = CONFIG.previewMaxSize;
                canvasHeight = canvasWidth / gridRatio;
            } else {
                canvasHeight = CONFIG.previewMaxSize;
                canvasWidth = canvasHeight * gridRatio;
            }
            
            canvasWidth = Math.round(canvasWidth);
            canvasHeight = Math.round(canvasHeight);
            
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
            
            // –ë–µ–ª—ã–π —Ñ–æ–Ω
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);
            
            // –í—ã—á–∏—Å–ª—è–µ–º –∫–∞–∫ —Ä–∞–∑–º–µ—Å—Ç–∏—Ç—å –∫–∞—Ä—Ç–∏–Ω–∫—É
            let imgDrawWidth, imgDrawHeight, imgDrawX, imgDrawY;
            
            if (state.fitMode === 'fit') {
                // –í–ø–∏—Å–∞—Ç—å —Ü–µ–ª–∏–∫–æ–º
                if (imgRatio > gridRatio) {
                    imgDrawWidth = canvasWidth;
                    imgDrawHeight = canvasWidth / imgRatio;
                } else {
                    imgDrawHeight = canvasHeight;
                    imgDrawWidth = canvasHeight * imgRatio;
                }
                imgDrawX = (canvasWidth - imgDrawWidth) / 2;
                imgDrawY = (canvasHeight - imgDrawHeight) / 2;
            } else {
                // –ó–∞–ø–æ–ª–Ω–∏—Ç—å
                if (imgRatio > gridRatio) {
                    imgDrawHeight = canvasHeight;
                    imgDrawWidth = canvasHeight * imgRatio;
                } else {
                    imgDrawWidth = canvasWidth;
                    imgDrawHeight = canvasWidth / imgRatio;
                }
                imgDrawX = (canvasWidth - imgDrawWidth) / 2;
                imgDrawY = (canvasHeight - imgDrawHeight) / 2;
            }
            
            // –†–∏—Å—É–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            ctx.drawImage(state.originalImage, imgDrawX, imgDrawY, imgDrawWidth, imgDrawHeight);
            
            // –†–∏—Å—É–µ–º —Å–µ—Ç–∫—É
            drawGrid(canvasWidth, canvasHeight, imgDrawX, imgDrawY, imgDrawWidth, imgDrawHeight);
            
            // –û–±–Ω–æ–≤–ª—è–µ–º —Ä–∞–∑–º–µ—Ä—ã
            document.getElementById('dimWidth').textContent = `${(gridWidthMM / 10).toFixed(0)} —Å–º`;
            document.getElementById('dimHeight').textContent = `${(gridHeightMM / 10).toFixed(0)} —Å–º`;
            
            // –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
            updateStats();
            
        } catch (err) {
            console.error('Preview error:', err);
        }
    }
    
    function drawGrid(canvasWidth, canvasHeight, imgX, imgY, imgWidth, imgHeight) {
        const svg = document.getElementById('gridLines');
        svg.setAttribute('width', canvasWidth);
        svg.setAttribute('height', canvasHeight);
        svg.innerHTML = '';
        
        const cellWidth = canvasWidth / state.gridCols;
        const cellHeight = canvasHeight / state.gridRows;
        
        // –†–∞–∑–º–µ—Ä –Ω–∞—Ö–ª—ë—Å—Ç–∞ –≤ –ø–∏–∫—Å–µ–ª—è—Ö
        const overlapPx = state.enableOverlap 
            ? (state.overlapAmount / getPaperSize().width) * cellWidth
            : 0;
        
        let hasPartial = false;
        
        for (let row = 0; row < state.gridRows; row++) {
            for (let col = 0; col < state.gridCols; col++) {
                const x = col * cellWidth;
                const y = row * cellHeight;
                
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º —á–∞—Å—Ç–∏—á–Ω–æ—Å—Ç—å –≤ —Ä–µ–∂–∏–º–µ fit
                let isPartial = false;
                if (state.fitMode === 'fit') {
                    const cellRight = x + cellWidth;
                    const cellBottom = y + cellHeight;
                    
                    // –Ø—á–µ–π–∫–∞ —á–∞—Å—Ç–∏—á–Ω–∞—è –µ—Å–ª–∏ –Ω–µ –ø–æ–ª–Ω–æ—Å—Ç—å—é –≤–Ω—É—Ç—Ä–∏ –∫–∞—Ä—Ç–∏–Ω–∫–∏
                    if (x < imgX || cellRight > imgX + imgWidth ||
                        y < imgY || cellBottom > imgY + imgHeight) {
                        
                        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ
                        const intersects = !(cellRight <= imgX || x >= imgX + imgWidth ||
                                             cellBottom <= imgY || y >= imgY + imgHeight);
                        
                        if (intersects || 
                            (x >= imgX && cellRight <= imgX + imgWidth && y >= imgY && cellBottom <= imgY + imgHeight)) {
                            isPartial = true;
                            hasPartial = true;
                        }
                    }
                }
                
                // –Ø—á–µ–π–∫–∞
                const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                rect.setAttribute('x', x);
                rect.setAttribute('y', y);
                rect.setAttribute('width', cellWidth);
                rect.setAttribute('height', cellHeight);
                rect.setAttribute('fill', isPartial ? 'rgba(255, 193, 7, 0.2)' : 'rgba(74, 144, 217, 0.15)');
                rect.setAttribute('stroke', isPartial ? 'rgba(255, 193, 7, 0.9)' : 'rgba(74, 144, 217, 0.9)');
                rect.setAttribute('stroke-width', '2');
                svg.appendChild(rect);
                
                // –ù–∞—Ö–ª—ë—Å—Ç
                if (state.enableOverlap && overlapPx > 0) {
                    // –°–ø—Ä–∞–≤–∞
                    if (col < state.gridCols - 1) {
                        const overlapRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                        overlapRect.setAttribute('x', x + cellWidth - overlapPx);
                        overlapRect.setAttribute('y', y);
                        overlapRect.setAttribute('width', overlapPx * 2);
                        overlapRect.setAttribute('height', cellHeight);
                        overlapRect.setAttribute('fill', 'rgba(46, 204, 113, 0.3)');
                        overlapRect.setAttribute('stroke', 'rgba(46, 204, 113, 0.8)');
                        overlapRect.setAttribute('stroke-width', '1');
                        overlapRect.setAttribute('stroke-dasharray', '4,2');
                        svg.appendChild(overlapRect);
                    }
                    
                    // –°–Ω–∏–∑—É
                    if (row < state.gridRows - 1) {
                        const overlapRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                        overlapRect.setAttribute('x', x);
                        overlapRect.setAttribute('y', y + cellHeight - overlapPx);
                        overlapRect.setAttribute('width', cellWidth);
                        overlapRect.setAttribute('height', overlapPx * 2);
                        overlapRect.setAttribute('fill', 'rgba(46, 204, 113, 0.3)');
                        overlapRect.setAttribute('stroke', 'rgba(46, 204, 113, 0.8)');
                        overlapRect.setAttribute('stroke-width', '1');
                        overlapRect.setAttribute('stroke-dasharray', '4,2');
                        svg.appendChild(overlapRect);
                    }
                }
            }
        }
        
        // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º/—Å–∫—Ä—ã–≤–∞–µ–º –ª–µ–≥–µ–Ω–¥—É —á–∞—Å—Ç–∏—á–Ω—ã—Ö
        document.getElementById('legendPartial').classList.toggle('hidden', !hasPartial);
    }
    
    function updateStats() {
        const paper = getPaperSize();
        const totalWidthCM = (paper.width * state.gridCols) / 10;
        const totalHeightCM = (paper.height * state.gridRows) / 10;
        const totalSheets = state.gridCols * state.gridRows;
        
        document.getElementById('statPosterSize').textContent = 
            `${totalWidthCM.toFixed(0)}√ó${totalHeightCM.toFixed(0)} —Å–º`;
        document.getElementById('statSheets').textContent = 
            `${totalSheets} ${getSheetWord(totalSheets)}`;
        
        // –ö–∞—á–µ—Å—Ç–≤–æ (DPI)
        const gridWidthMM = paper.width * state.gridCols;
        const gridHeightMM = paper.height * state.gridRows;
        const gridWidthInch = gridWidthMM / CONFIG.mmToInch;
        const gridHeightInch = gridHeightMM / CONFIG.mmToInch;
        
        const dpiX = state.imageWidth / gridWidthInch;
        const dpiY = state.imageHeight / gridHeightInch;
        const dpi = Math.min(dpiX, dpiY);
        
        const qualityEl = document.getElementById('statQuality');
        if (dpi >= 150) {
            qualityEl.textContent = `${Math.round(dpi)} DPI`;
            qualityEl.className = 'preview-stat-value quality-good';
        } else if (dpi >= 72) {
            qualityEl.textContent = `${Math.round(dpi)} DPI`;
            qualityEl.className = 'preview-stat-value quality-medium';
        } else {
            qualityEl.textContent = `${Math.round(dpi)} DPI`;
            qualityEl.className = 'preview-stat-value quality-bad';
        }
    }

    // ============================================
    // –ö–†–û–ü–ü–ï–†
    // ============================================
    function openCropper() {
        if (!state.originalDataUrl) return;
        
        const modal = document.getElementById('cropperModal');
        const cropperImage = document.getElementById('cropperImage');
        
        modal.classList.add('active');
        cropperImage.src = state.originalDataUrl;
        
        // –£–Ω–∏—á—Ç–æ–∂–∞–µ–º —Å—Ç–∞—Ä—ã–π
        if (state.cropper) {
            state.cropper.destroy();
            state.cropper = null;
        }
        
        // –ñ–¥—ë–º –∑–∞–≥—Ä—É–∑–∫–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
        cropperImage.onload = () => {
            try {
                state.cropper = new Cropper(cropperImage, {
                    viewMode: 1,
                    dragMode: 'move',
                    autoCropArea: 1,
                    restore: false,
                    guides: true,
                    center: true,
                    highlight: false,
                    cropBoxMovable: true,
                    cropBoxResizable: true,
                    toggleDragModeOnDblclick: false,
                    ready: function() {
                        // –ö—Ä–æ–ø–ø–µ—Ä –≥–æ—Ç–æ–≤
                    }
                });
            } catch (err) {
                console.error('Cropper init error:', err);
                closeCropper();
            }
        };
    }
    
    function closeCropper() {
        const modal = document.getElementById('cropperModal');
        modal.classList.remove('active');
        
        if (state.cropper) {
            try {
                state.cropper.destroy();
            } catch (e) {}
            state.cropper = null;
        }
    }
    
    function applyCrop() {
        if (!state.cropper) {
            closeCropper();
            return;
        }
        
        try {
            const croppedCanvas = state.cropper.getCroppedCanvas({
                maxWidth: 8000,
                maxHeight: 8000,
                imageSmoothingEnabled: true,
                imageSmoothingQuality: 'high'
            });
            
            if (!croppedCanvas) {
                console.error('Failed to get cropped canvas');
                closeCropper();
                return;
            }
            
            const dataUrl = croppedCanvas.toDataURL('image/jpeg', 0.95);
            
            const img = new Image();
            img.onload = () => {
                state.originalImage = img;
                state.originalDataUrl = dataUrl;
                state.imageWidth = img.naturalWidth;
                state.imageHeight = img.naturalHeight;
                
                // –û–±–Ω–æ–≤–ª—è–µ–º –∫–∞—Ä—Ç–∏–Ω–∫—É –≤ –∫—Ä–æ–ø–ø–µ—Ä–µ –¥–ª—è —Å–ª–µ–¥—É—é—â–µ–≥–æ —Ä–∞–∑–∞
                document.getElementById('cropperImage').src = dataUrl;
                
                closeCropper();
                updatePreview();
                updateResolutionInfo();
            };
            
            img.onerror = () => {
                console.error('Failed to load cropped image');
                closeCropper();
            };
            
            img.src = dataUrl;
            
            // –û—á–∏—â–∞–µ–º canvas
            cleanupCanvas(croppedCanvas);
            
        } catch (err) {
            console.error('Crop error:', err);
            closeCropper();
        }
    }

    // ============================================
    // –û–ë–†–ê–ë–û–¢–ö–ê –ò–ó–û–ë–†–ê–ñ–ï–ù–ò–Ø (–±–µ–∑ –∑–∞–≤–∏—Å–∞–Ω–∏–π)
    // ============================================
    async function processImageData(imageData, width, height, onProgress) {
        const data = imageData.data;
        const totalPixels = width * height;
        const chunkSize = CONFIG.chunkSize;
        
        // –Ø—Ä–∫–æ—Å—Ç—å –∏ –∫–æ–Ω—Ç—Ä–∞—Å—Ç
        const contrast = state.contrast;
        const brightness = state.brightness;
        const saturation = state.saturation;
        
        const contrastFactor = (259 * (contrast + 255)) / (255 * (259 - contrast));
        const brightnessOffset = brightness * 2.55;
        const satFactor = 1 + saturation / 100;
        
        await processInChunks(totalPixels, chunkSize, async (start, end) => {
            for (let i = start; i < end; i++) {
                const idx = i * 4;
                
                let r = data[idx];
                let g = data[idx + 1];
                let b = data[idx + 2];
                
                // –Ø—Ä–∫–æ—Å—Ç—å
                r += brightnessOffset;
                g += brightnessOffset;
                b += brightnessOffset;
                
                // –ö–æ–Ω—Ç—Ä–∞—Å—Ç
                r = contrastFactor * (r - 128) + 128;
                g = contrastFactor * (g - 128) + 128;
                b = contrastFactor * (b - 128) + 128;
                
                // –ù–∞—Å—ã—â–µ–Ω–Ω–æ—Å—Ç—å
                const gray = 0.2989 * r + 0.587 * g + 0.114 * b;
                r = gray + satFactor * (r - gray);
                g = gray + satFactor * (g - gray);
                b = gray + satFactor * (b - gray);
                
                // Clamp
                data[idx] = Math.max(0, Math.min(255, r));
                data[idx + 1] = Math.max(0, Math.min(255, g));
                data[idx + 2] = Math.max(0, Math.min(255, b));
            }
        }, onProgress);
        
        return imageData;
    }
    
    async function applySharpening(ctx, width, height, amount, onProgress) {
        if (amount <= 0) return;
        
        const strength = amount / 100;
        const original = ctx.getImageData(0, 0, width, height);
        const origData = original.data;
        
        // –°–æ–∑–¥–∞—ë–º —Ä–∞–∑–º—ã—Ç—É—é –≤–µ—Ä—Å–∏—é
        const blurred = ctx.getImageData(0, 0, width, height);
        const blurData = blurred.data;
        
        const totalPixels = width * height;
        const chunkSize = CONFIG.chunkSize;
        
        // Box blur
        await processInChunks(totalPixels, chunkSize, async (start, end) => {
            for (let i = start; i < end; i++) {
                const x = i % width;
                const y = Math.floor(i / width);
                
                let r = 0, g = 0, b = 0, count = 0;
                
                for (let dy = -1; dy <= 1; dy++) {
                    for (let dx = -1; dx <= 1; dx++) {
                        const nx = Math.min(width - 1, Math.max(0, x + dx));
                        const ny = Math.min(height - 1, Math.max(0, y + dy));
                        const idx = (ny * width + nx) * 4;
                        
                        r += origData[idx];
                        g += origData[idx + 1];
                        b += origData[idx + 2];
                        count++;
                    }
                }
                
                const idx = i * 4;
                blurData[idx] = r / count;
                blurData[idx + 1] = g / count;
                blurData[idx + 2] = b / count;
            }
        }, (p) => onProgress && onProgress(p * 0.5));
        
        // Unsharp mask
        await processInChunks(totalPixels, chunkSize, async (start, end) => {
            for (let i = start; i < end; i++) {
                const idx = i * 4;
                for (let j = 0; j < 3; j++) {
                    const diff = origData[idx + j] - blurData[idx + j];
                    origData[idx + j] = Math.max(0, Math.min(255, origData[idx + j] + diff * strength * 2));
                }
            }
        }, (p) => onProgress && onProgress(0.5 + p * 0.5));
        
        ctx.putImageData(original, 0, 0);
    }

    // ============================================
    // –ì–ï–ù–ï–†–ê–¶–ò–Ø
    // ============================================
    async function generateOutput() {
        if (state.isProcessing) return;
        state.isProcessing = true;
        
        const generateBtn = document.getElementById('generateBtn');
        generateBtn.disabled = true;
        
        showProgress('–ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞...', 0);
        
        try {
            const fragments = await generateFragments();
            
            switch (state.exportFormat) {
                case 'docx':
                    await generateDOCX(fragments);
                    break;
                case 'pdf':
                    await generatePDF(fragments);
                    break;
                case 'zip':
                    await generateZIP(fragments);
                    break;
            }
            
            document.getElementById('step2').classList.remove('active');
            document.getElementById('step2').classList.add('completed');
            document.getElementById('step3').classList.add('active');
            
        } catch (error) {
            console.error('Generation error:', error);
            alert('–û—à–∏–±–∫–∞: ' + (error.message || '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞'));
        } finally {
            hideProgress();
            generateBtn.disabled = false;
            state.isProcessing = false;
        }
    }
    
    async function generateFragments() {
        const sourceImg = state.originalImage;
        const paper = getPaperSize();
        const dpi = state.enableUpscale ? state.targetDPI : 150;
        
        // –†–∞–∑–º–µ—Ä –ª–∏—Å—Ç–∞ –≤ –ø–∏–∫—Å–µ–ª—è—Ö
        const sheetWidthPx = Math.round((paper.width / CONFIG.mmToInch) * dpi);
        const sheetHeightPx = Math.round((paper.height / CONFIG.mmToInch) * dpi);
        
        // –ù–∞—Ö–ª—ë—Å—Ç –≤ –ø–∏–∫—Å–µ–ª—è—Ö
        const overlapPx = state.enableOverlap 
            ? Math.round((state.overlapAmount / CONFIG.mmToInch) * dpi)
            : 0;
        
        // –û–±—â–∏–π —Ä–∞–∑–º–µ—Ä
        const gridWidthPx = sheetWidthPx * state.gridCols;
        const gridHeightPx = sheetHeightPx * state.gridRows;
        
        updateProgress('–°–æ–∑–¥–∞—ë–º –ø–æ–ª–Ω–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ...', 5);
        await delay(10);
        
        // –°–æ–∑–¥–∞—ë–º –±–æ–ª—å—à–æ–π canvas –ø–æ—Å—Ç–µ—Ä–∞
        const posterCanvas = document.createElement('canvas');
        posterCanvas.width = gridWidthPx;
        posterCanvas.height = gridHeightPx;
        const posterCtx = posterCanvas.getContext('2d');
        
        // –ë–µ–ª—ã–π —Ñ–æ–Ω
        posterCtx.fillStyle = '#ffffff';
        posterCtx.fillRect(0, 0, gridWidthPx, gridHeightPx);
        
        // –†–∞–∑–º–µ—â–µ–Ω–∏–µ –∫–∞—Ä—Ç–∏–Ω–∫–∏
        const gridRatio = gridWidthPx / gridHeightPx;
        const imgRatio = sourceImg.naturalWidth / sourceImg.naturalHeight;
        
        let imgDrawWidth, imgDrawHeight, imgDrawX, imgDrawY;
        
        if (state.fitMode === 'fit') {
            if (imgRatio > gridRatio) {
                imgDrawWidth = gridWidthPx;
                imgDrawHeight = gridWidthPx / imgRatio;
            } else {
                imgDrawHeight = gridHeightPx;
                imgDrawWidth = gridHeightPx * imgRatio;
            }
            imgDrawX = (gridWidthPx - imgDrawWidth) / 2;
            imgDrawY = (gridHeightPx - imgDrawHeight) / 2;
        } else {
            if (imgRatio > gridRatio) {
                imgDrawHeight = gridHeightPx;
                imgDrawWidth = gridHeightPx * imgRatio;
            } else {
                imgDrawWidth = gridWidthPx;
                imgDrawHeight = gridWidthPx / imgRatio;
            }
            imgDrawX = (gridWidthPx - imgDrawWidth) / 2;
            imgDrawY = (gridHeightPx - imgDrawHeight) / 2;
        }
        
        updateProgress('–ú–∞—Å—à—Ç–∞–±–∏—Ä—É–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ...', 10);
        await delay(10);
        
        // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ —Å–≥–ª–∞–∂–∏–≤–∞–Ω–∏—è
        if (state.upscalePreset === 'pixel') {
            posterCtx.imageSmoothingEnabled = false;
        } else {
            posterCtx.imageSmoothingEnabled = true;
            posterCtx.imageSmoothingQuality = 'high';
        }
        
        // –†–∏—Å—É–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ
        posterCtx.drawImage(sourceImg, imgDrawX, imgDrawY, imgDrawWidth, imgDrawHeight);
        
        // –ü—Ä–∏–º–µ–Ω—è–µ–º –æ–±—Ä–∞–±–æ—Ç–∫—É –µ—Å–ª–∏ –∞–ø—Å–∫–µ–π–ª –≤–∫–ª—é—á—ë–Ω
        if (state.enableUpscale && state.upscalePreset !== 'pixel') {
            updateProgress('–£–ª—É—á—à–∞–µ–º –∫–∞—á–µ—Å—Ç–≤–æ...', 15);
            
            const imageData = posterCtx.getImageData(0, 0, gridWidthPx, gridHeightPx);
            
            await processImageData(imageData, gridWidthPx, gridHeightPx, (p) => {
                updateProgress('–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Ü–≤–µ—Ç–∞...', 15 + p * 20);
            });
            
            posterCtx.putImageData(imageData, 0, 0);
            
            if (state.sharpen > 0) {
                await applySharpening(posterCtx, gridWidthPx, gridHeightPx, state.sharpen, (p) => {
                    updateProgress('–ü–æ–≤—ã—à–∞–µ–º —Ä–µ–∑–∫–æ—Å—Ç—å...', 35 + p * 15);
                });
            }
        }
        
        // –ù–∞—Ä–µ–∑–∞–µ–º –Ω–∞ —Ñ—Ä–∞–≥–º–µ–Ω—Ç—ã
        const fragments = [];
        const totalFragments = state.gridCols * state.gridRows;
        let fragmentIndex = 0;
        
        for (let row = 0; row < state.gridRows; row++) {
            for (let col = 0; col < state.gridCols; col++) {
                fragmentIndex++;
                
                const progress = 50 + (fragmentIndex / totalFragments) * 40;
                updateProgress(`–°–æ–∑–¥–∞—ë–º —Ñ—Ä–∞–≥–º–µ–Ω—Ç ${fragmentIndex}/${totalFragments}...`, progress);
                setProgressDetails(`–°—Ç—Ä–æ–∫–∞ ${row + 1}, —Å—Ç–æ–ª–±–µ—Ü ${col + 1}`);
                
                const srcX = col * sheetWidthPx;
                const srcY = row * sheetHeightPx;
                
                // –†–∞–∑–º–µ—Ä —Å –Ω–∞—Ö–ª—ë—Å—Ç–æ–º
                let fragWidth = sheetWidthPx;
                let fragHeight = sheetHeightPx;
                
                const hasOverlapRight = state.enableOverlap && col < state.gridCols - 1;
                const hasOverlapBottom = state.enableOverlap && row < state.gridRows - 1;
                
                if (hasOverlapRight) fragWidth += overlapPx;
                if (hasOverlapBottom) fragHeight += overlapPx;
                
                // –°–æ–∑–¥–∞—ë–º canvas –¥–ª—è —Ñ—Ä–∞–≥–º–µ–Ω—Ç–∞
                const fragCanvas = document.createElement('canvas');
                fragCanvas.width = fragWidth;
                fragCanvas.height = fragHeight;
                const fragCtx = fragCanvas.getContext('2d');
                
                fragCtx.fillStyle = '#ffffff';
                fragCtx.fillRect(0, 0, fragWidth, fragHeight);
                
                fragCtx.drawImage(
                    posterCanvas,
                    srcX, srcY, fragWidth, fragHeight,
                    0, 0, fragWidth, fragHeight
                );
                
                // –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –≤ blob
                const blob = await new Promise((resolve, reject) => {
                    try {
                        fragCanvas.toBlob(
                            (b) => b ? resolve(b) : reject(new Error('Blob creation failed')),
                            'image/jpeg',
                            0.92
                        );
                    } catch (e) {
                        reject(e);
                    }
                });
                
                fragments.push({
                    row,
                    col,
                    label: `${String.fromCharCode(65 + row)}${col + 1}`,
                    blob,
                    width: fragWidth,
                    height: fragHeight,
                    hasOverlapRight,
                    hasOverlapBottom
                });
                
                // –û—á–∏—â–∞–µ–º –ø–∞–º—è—Ç—å
                cleanupCanvas(fragCanvas);
                
                await delay(5);
            }
        }
        
        // –û—á–∏—â–∞–µ–º –±–æ–ª—å—à–æ–π canvas
        cleanupCanvas(posterCanvas);
        
        return fragments;
    }
    
    async function generateDOCX(fragments) {
        updateProgress('–°–æ–∑–¥–∞—ë–º DOCX...', 92);
        
        const { Document, Packer, Paragraph, ImageRun, PageOrientation, convertMillimetersToTwip } = docx;
        
        const paper = getPaperSize();
        const sections = [];
        
        for (let i = 0; i < fragments.length; i++) {
            const fragment = fragments[i];
            
            setProgressDetails(`–î–æ–±–∞–≤–ª—è–µ–º —Å—Ç—Ä–∞–Ω–∏—Ü—É ${i + 1}/${fragments.length}`);
            
            const arrayBuffer = await fragment.blob.arrayBuffer();
            const uint8Array = new Uint8Array(arrayBuffer);
            
            let pageWidth = paper.width;
            let pageHeight = paper.height;
            
            if (fragment.hasOverlapRight) pageWidth += state.overlapAmount;
            if (fragment.hasOverlapBottom) pageHeight += state.overlapAmount;
            
            sections.push({
                properties: {
                    page: {
                        size: {
                            width: convertMillimetersToTwip(pageWidth),
                            height: convertMillimetersToTwip(pageHeight),
                            orientation: state.orientation === 'landscape' 
                                ? PageOrientation.LANDSCAPE 
                                : PageOrientation.PORTRAIT
                        },
                        margin: { top: 0, right: 0, bottom: 0, left: 0 }
                    }
                },
                children: [
                    new Paragraph({
                        children: [
                            new ImageRun({
                                data: uint8Array,
                                transformation: {
                                    width: convertMillimetersToTwip(pageWidth) / 15,
                                    height: convertMillimetersToTwip(pageHeight) / 15
                                },
                                type: 'jpg'
                            })
                        ]
                    })
                ]
            });
            
            await delay(5);
        }
        
        updateProgress('–°–æ—Ö—Ä–∞–Ω—è–µ–º —Ñ–∞–π–ª...', 98);
        
        const doc = new Document({ sections });
        const blob = await Packer.toBlob(doc);
        saveAs(blob, `poster_${state.gridCols}x${state.gridRows}.docx`);
    }
    
    async function generatePDF(fragments) {
        updateProgress('–°–æ–∑–¥–∞—ë–º PDF...', 92);
        
        const { PDFDocument } = PDFLib;
        const pdfDoc = await PDFDocument.create();
        
        const paper = getPaperSize();
        
        for (let i = 0; i < fragments.length; i++) {
            const fragment = fragments[i];
            
            setProgressDetails(`–î–æ–±–∞–≤–ª—è–µ–º —Å—Ç—Ä–∞–Ω–∏—Ü—É ${i + 1}/${fragments.length}`);
            
            let pageWidth = paper.width * CONFIG.mmToPoint;
            let pageHeight = paper.height * CONFIG.mmToPoint;
            
            if (fragment.hasOverlapRight) pageWidth += state.overlapAmount * CONFIG.mmToPoint;
            if (fragment.hasOverlapBottom) pageHeight += state.overlapAmount * CONFIG.mmToPoint;
            
            const page = pdfDoc.addPage([pageWidth, pageHeight]);
            
            const arrayBuffer = await fragment.blob.arrayBuffer();
            const image = await pdfDoc.embedJpg(arrayBuffer);
            
            page.drawImage(image, {
                x: 0,
                y: 0,
                width: pageWidth,
                height: pageHeight
            });
            
            await delay(5);
        }
        
        updateProgress('–°–æ—Ö—Ä–∞–Ω—è–µ–º —Ñ–∞–π–ª...', 98);
        
        const pdfBytes = await pdfDoc.save();
        const blob = new Blob([pdfBytes], { type: 'application/pdf' });
        saveAs(blob, `poster_${state.gridCols}x${state.gridRows}.pdf`);
    }
    
    async function generateZIP(fragments) {
        updateProgress('–°–æ–∑–¥–∞—ë–º ZIP...', 92);
        
        const zip = new JSZip();
        const folder = zip.folder('poster');
        
        for (let i = 0; i < fragments.length; i++) {
            const fragment = fragments[i];
            setProgressDetails(`–î–æ–±–∞–≤–ª—è–µ–º ${fragment.label}.jpg`);
            folder.file(`${fragment.label}.jpg`, fragment.blob);
            await delay(5);
        }
        
        // README
        const readme = `–ü–æ—Å—Ç–µ—Ä ${state.gridCols}√ó${state.gridRows}
================

–°–µ—Ç–∫–∞ —Å–±–æ—Ä–∫–∏:
${generateGridMap()}

–§–æ—Ä–º–∞—Ç: ${state.paperFormat} (${state.orientation === 'portrait' ? '–ø–æ—Ä—Ç—Ä–µ—Ç' : '–∞–ª—å–±–æ–º'})
${state.enableOverlap ? `–ù–∞—Ö–ª—ë—Å—Ç: ${state.overlapAmount} –º–º` : '–ë–µ–∑ –Ω–∞—Ö–ª—ë—Å—Ç–∞'}
`;
        folder.file('README.txt', readme);
        
        updateProgress('–°–æ—Ö—Ä–∞–Ω—è–µ–º –∞—Ä—Ö–∏–≤...', 98);
        
        const blob = await zip.generateAsync({ 
            type: 'blob',
            compression: 'DEFLATE',
            compressionOptions: { level: 6 }
        });
        
        saveAs(blob, `poster_${state.gridCols}x${state.gridRows}.zip`);
    }
    
    function generateGridMap() {
        let map = '';
        for (let row = 0; row < state.gridRows; row++) {
            let rowStr = '';
            for (let col = 0; col < state.gridCols; col++) {
                rowStr += `[${String.fromCharCode(65 + row)}${col + 1}] `;
            }
            map += rowStr.trim() + '\n';
        }
        return map;
    }

    // ============================================
    // –ü–†–û–ì–†–ï–°–°
    // ============================================
    function showProgress(text, percent = 0) {
        document.getElementById('progressText').textContent = text;
        document.getElementById('progressBar').style.width = percent + '%';
        document.getElementById('progressDetails').textContent = '';
        document.getElementById('progressOverlay').classList.add('active');
    }
    
    function updateProgress(text, percent) {
        document.getElementById('progressText').textContent = text;
        document.getElementById('progressBar').style.width = percent + '%';
    }
    
    function setProgressDetails(text) {
        document.getElementById('progressDetails').textContent = text;
    }
    
    function hideProgress() {
        document.getElementById('progressOverlay').classList.remove('active');
    }
    </script>
</body>
</html>
